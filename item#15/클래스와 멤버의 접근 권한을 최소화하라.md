## 클래스와 인터페이스의 접근 제한자 사용 원칙
* 모든 클래스와 멤버의 접근성을 가능한 한 좁혀야 한다.
* 톱레벨 클래스와 인터페이스에 package-private 또는 public을 쓸 수 있다. 
  * public으로 선언하면 API가 되므로 하위 호환성을 유지하려면 영원히 관리해야한다.
  * 패키지 외부에서 쓰지 않을 클래스나 인터페이스라면 package-private으로 선언한다.
* 한 클래스에서만 사용하는 package-private 클래스나 인터페이스는 해당 클래스에 private static으로 중첩 시키자 (item 24)


![image](https://user-images.githubusercontent.com/67637716/224220998-eae08701-f2b9-4ca7-8282-b07abff09441.png)  
top level이기 때문에 public, package-private으로밖에 사용 불가  

Spring IOC Container, Service Loader등, interface만으로 사용하게 하고싶을때 구현체는 package-private으로 만든다.

``` java 
public interface MemberService {

}

public class Member {

}

class DefaultMemberService implements MemberService {
    // item은 MemberService의 어떤 구현체인지를 알필요가 없다.
    // 인터페이스만으로 코딩을 하길 바란다.

}

```  

#### 한 클래스에서만 사용하는 package-private 클래스나 인터페이스는 해당 클래스에 private static으로 중첩 시키자
``` java
interface MemberRepository {

}

class DefaultMemberService implements MemberService {
    // item은 MemberService의 어떤 구현체인지를 알필요가 없다.
    // 인터페이스만으로 코딩을 하길 바란다.

    MemberRepository memberRepository;
    
    public Member getMember(){
        return memberRepository.findById();
    }
    
}
```  
위와 같은 MemberRepository를 DefaultMemberServices 내에서만 사용한다고 했을 때, 밑에와 같이 사용 가능.  

``` java
class DefaultMemberService implements MemberService {
    // item은 MemberService의 어떤 구현체인지를 알필요가 없다.
    // 인터페이스만으로 코딩을 하길 바란다.

    private String name;

    private static class PrivateStaticClass {
        // 왜 static일까?
        // inner class지만 외부 클래스의 레퍼런스가 없다.
        void doPrint() {
            System.out.println(name); // compile error
        }
        
    }

    private class PrivateClass {
        // 외부 인스턴스를 참조한다.
        // 항상 자동으로 인스턴스를 참조하는 필드가 생김
        void doPrint() {
            System.out.println(name);
        }
    }
}
```  

