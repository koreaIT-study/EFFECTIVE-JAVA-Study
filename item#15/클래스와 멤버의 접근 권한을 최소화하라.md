# 구현과 API를 분리하는 `정보 은닉`의 장점
* 시스템 개발 속도를 높인다. (여러 컴포넌트를 병렬로 개발할 수 있기 때문에) => 인터페이스를 만들고 병렬로 구현체 개발
* 시스템 관리 비용을 낮춘다. (컴퍼넌트를 더 빨리 파악할 수 있기 때문에) => 인터페이스 위주로 코드를 살펴보면 파악이 빠르고, 문제가 생겼을 때 디버깅 빠르게 할 수 있다.
* 성능 최적화에 도움을 준다. (프로파일링을 통해 최적화할 컴포넌트를 찾고 다른 컴포넌트에 영향을 주지 않고 해당 컴포너트만 개선할 수 있기 때문에) => 성능의 병목지점을 찾아내는게 용의하는 뜻이다.
* 소프트웨어 재사용성을 높인다. (독자적인 컴포넌트라면) => 어떤 컴포넌트가 다른 곳에서도 사용할수 있는 컴포넌트라면
* 시스템 개발 난이도를 낮춘다. (전체를 만들기 전에 개별 컴포넌트를 검증할 수 있기 때문에) => divide and conquer (분할 정복) 

## 클래스와 인터페이스의 접근 제한자 사용 원칙
* 모든 클래스와 멤버의 접근성을 가능한 한 좁혀야 한다.
* 톱레벨 클래스와 인터페이스에 package-private 또는 public을 쓸 수 있다. 
  * public으로 선언하면 API가 되므로 하위 호환성을 유지하려면 영원히 관리해야한다.
  * 패키지 외부에서 쓰지 않을 클래스나 인터페이스라면 package-private으로 선언한다.
* 한 클래스에서만 사용하는 package-private 클래스나 인터페이스는 해당 클래스에 private static으로 중첩 시키자 (item 24)


![image](https://user-images.githubusercontent.com/67637716/224220998-eae08701-f2b9-4ca7-8282-b07abff09441.png)  
top level이기 때문에 public, package-private으로밖에 사용 불가  

Spring IOC Container, Service Loader등, interface만으로 사용하게 하고싶을때 구현체는 package-private으로 만든다.

``` java 
public interface MemberService {

}

public class Member {

}

class DefaultMemberService implements MemberService {
    // item은 MemberService의 어떤 구현체인지를 알필요가 없다.
    // 인터페이스만으로 코딩을 하길 바란다.

}

```  

#### 한 클래스에서만 사용하는 package-private 클래스나 인터페이스는 해당 클래스에 private static으로 중첩 시키자
``` java
interface MemberRepository {

}

class DefaultMemberService implements MemberService {
    // item은 MemberService의 어떤 구현체인지를 알필요가 없다.
    // 인터페이스만으로 코딩을 하길 바란다.

    MemberRepository memberRepository;
    
    public Member getMember(){
        return memberRepository.findById();
    }
    
}
```  
위와 같은 MemberRepository를 DefaultMemberServices 내에서만 사용한다고 했을 때, 밑에와 같이 사용 가능.  

``` java
class DefaultMemberService implements MemberService {
    // item은 MemberService의 어떤 구현체인지를 알필요가 없다.
    // 인터페이스만으로 코딩을 하길 바란다.

    private String name;

    private static class PrivateStaticClass {
        // 왜 static일까?
        // inner class지만 외부 클래스의 레퍼런스가 없다.
        void doPrint() {
            System.out.println(name); // compile error
        }
        
    }

    private class PrivateClass {
        // 외부 인스턴스를 참조한다.
        // 항상 자동으로 인스턴스를 참조하는 필드가 생김
        void doPrint() {
            System.out.println(name);
        }
    }
}
```  

## 멤버의 접근 제한자 사용 원칙



