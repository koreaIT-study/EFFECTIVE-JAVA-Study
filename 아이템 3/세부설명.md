**목차**<br>
1. [싱글턴을 사용하는 클라이언트를 테스트하기가 어려워질 수 있다.](#싱글턴을-사용하는-클라이언트를-테스트하기가-어려워질-수-있다.)
2. [리플렉션을 사용하면 싱글턴이 깨진다.](#리플렉션을-사용하면-싱글턴이-깨진다.)
3. [직렬화 후 역직렬화 문제.](#직렬화-후-역직렬화-문제.)
# 싱글턴을 사용하는 클라이언트를 테스트하기가 어려워질 수 있다.
```java
public class Concert {
    private boolean lightsOn;
    private boolean mainStateOpen;
    private Elvis elvis;

    public Concert(Elvis elvis) {this.elvis = elvis;}
    
    public void perform() {
        mainStateOpen = true;
        lightsOn = true;
        elvis.sing();
    }
    public boolean isLightsOn() {return lightsOn;}
    public boolean isMainStateOpen() {return mainStateOpen;}
}
```
위와 같이 싱글턴을 사용할 때는 싱글턴의 메서드가 비용이 크다면 테스트마다 큰 비용을 지불해야함.<br>
이럴 때는 아래와 같이 인터페이스를 구현한 mock 객체로 테스트를 하면 됨.
```java
public class Concert {
    private boolean lightsOn;
    private boolean mainStateOpen;
    private IElvis elvis;

    // 콘서트 생성자에 mock 객체를 전달 받음. 받을때 인터페이스로 받음.
    public Concert(IElvis elvis) {this.elvis = elvis;}
    
    public void perform() {
        mainStateOpen = true;
        lightsOn = true;
        elvis.sing();
    }
    public boolean isLightsOn() {return lightsOn;}

    public boolean isMainStateOpen() {return mainStateOpen;}
}
```
# 리플렉션을 사용하면 싱글턴이 깨진다.
```java
public class ElvisReflection {
    public static void main(String[] args) {
        try {
            Constructor<Elvis> defaultConstructor = Elvis.class.getDeclaredConstructor();
            Elvis elvis1 = defaultConstructor.newInstance();
            Elvis elvis2 = defaultConstructor.newInstance();
            System.out.println(elvis1 == elvis2);
            System.out.println(elvis1 == Elvis.INSTANCE);
        } catch (InvocationTargetException | NoSuchMethodException | InstantiationException | IllegalAccessException e) {
            e.printStackTrace();
        }
    }
}
```
위와 같이 리플렉션을 해도 인스턴스를 가져올때는<br>
```java
java.lang.IllegalAccessException: class me.whiteship.chapter01.item03.field.ElvisReflection cannot access a member of class me.whiteship.chapter01.item03.field.Elvis with modifiers "private"
	at java.base/jdk.internal.reflect.Reflection.newIllegalAccessException(Reflection.java:361)
	at java.base/java.lang.reflect.AccessibleObject.checkAccess(AccessibleObject.java:591)
	at java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:481)
	at me.whiteship.chapter01.item03.field.ElvisReflection.main(ElvisReflection.java:12)
```
private 이라 접근할 수 없다고 에러가 뜨나.
```java
public class ElvisReflection {
    public static void main(String[] args) {
        try {
            Constructor<Elvis> defaultConstructor = Elvis.class.getDeclaredConstructor();
            defaultConstructor.setAccessible(true);
            Elvis elvis1 = defaultConstructor.newInstance();
            Elvis elvis2 = defaultConstructor.newInstance();
            System.out.println(elvis1 == elvis2);
            System.out.println(elvis1 == Elvis.INSTANCE);
        } catch (InvocationTargetException | NoSuchMethodException | InstantiationException | IllegalAccessException e) {
            e.printStackTrace();
        }
    }
}
```
accessible 을 true 로 주게 되면 private 생성자를 사용하게될 뿐만 아니라.<br>
![image](https://user-images.githubusercontent.com/92290312/217567183-3f8a7817-0317-4489-81e2-9f0261d96ff3.png)
<br>
생성자를 사용하게 되었기 때문에 모두 다른 객체를 반환한다. => 싱글턴이 깨짐.<br>
=> 이걸 해결하기 위해 flag 를 줘서 해결할 수 있는데 소스가 간결해지지 않음.

# 직렬화 후 역직렬화 문제.
```java
public class ElvisSerialization {
    public static void main(String[] args) {
        try (ObjectOutput out = new ObjectOutputStream(new FileOutputStream("elvis.obj"))) {
            out.writeObject(Elvis.INSTANCE);
        } catch (IOException e) {
            e.printStackTrace();
        }
        try (ObjectInput in = new ObjectInputStream(new FileInputStream("elvis.obj"))) {
            Elvis elvis3 = (Elvis) in.readObject();
            System.out.println(elvis3 == Elvis.INSTANCE);
        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
}
```
직렬화 : 객체의 정보를 어딘가에 저장해놓고, 역직렬화 : 어딘가에 저장되어있는 객체정보들을 읽어옴.<br/>
역직렬화 시 생성자를 사용하기 때문에 다른 인스턴스를 불러옴.<br/>
![image](https://user-images.githubusercontent.com/92290312/218496743-93035930-cef5-40c1-b4c8-c482cf42359d.png)
```java
// Elvis 클래스에 메서드를 만들어줌
    private Object readResolve() {
        return INSTANCE;
    }
```
readResolve 라는 메서드를 역직렬화 시 사용하기 때문에 저 메서드를 정의해주면 미리 만들어둔 인스턴스를 리턴할 수 있게됨.
![image](https://user-images.githubusercontent.com/92290312/218497294-371c7e34-3347-44e9-9448-04d4625d416f.png)

